//
//  main.swift
//  Bian
//
//  Created by Ashley Cameron on 27/07/2020.
//

import Foundation
import ArgumentParser

struct Bian: ParsableCommand {

	// MARK: - Arguments

	@Option(
		name: .customLong("icons-dir"),
		help: "Path to directory which will be scanned for icon image assets to parse.",
		transform: { URL(fileURLWithPath: $0) }
	)
	var iconsDirectory: URL

	@Option(
		name: .customLong("info-plist"),
		help: "Path to the app Info.plist which will be updated to reflect the found icon images."
	)
	var infoPlistPath: String

	@Option(
		name: .customLong("swift-output"),
		help: "Path to create autogenerated .swift enum file for each icon case. Will replace any existing file at this location.",
		transform: { URL(fileURLWithPath: $0) }
	)
	var swiftOutput: URL?

	@Option(
		name: .customLong("xcassets-output"),
		help: "Path to create XCAssets file with found icon images. Will replace any existing file at this location."
	)
	var xcassetsOutput: String?

	// MARK: - Execution

	mutating func run() throws {
		let retrievedImages = try retrieveImages()
		let iconNames = FoundIconImagesParser.uniqueSortedNames(from: retrievedImages)
		let iconEntries = Dictionary(
			uniqueKeysWithValues: iconNames.map { ($0, InfoPlistIconEntry(iconName: $0)) }
		)
		let bundleIconsEntry = CFBundleIconsEntry(
			CFBundleAlternateIcons: iconEntries,
			CFBundlePrimaryIcon: try primaryIconEntry(infoPlistPath: infoPlistPath)
		)
		let bundleIconsEntryData = try JSONEncoder().encode(bundleIconsEntry)
		guard let bundleIconsDictionary = try JSONSerialization.jsonObject(with: bundleIconsEntryData, options: []) as? [String : Any] else {
			throw BianError.invalidData
		}
		guard let originalPlist = NSDictionary(contentsOf: URL(fileURLWithPath: infoPlistPath)) else {
			throw BianError.failedToFindInfoPlist
		}
		originalPlist.setValue(bundleIconsDictionary, forKey: InfoPlistKey.bundleIcons.rawValue)
		try FileUtils.createPlist(dictionary: originalPlist, path: infoPlistPath)
		print("Updated Info.plist with \(iconEntries.count) alternate icon files")

		if let url = swiftOutput {
			try SwiftFileGenerator.createIconsEnum(url: url, iconNames: iconNames)
			print("Created .swift output file for icon cases")
		}
		else {
			print("Skipping creation of .swift output file as no path provided")
		}
		if let path = xcassetsOutput {
			try createAssetsFile(path: path, images: retrievedImages)
			print("Created .xcassets file")
		}
		else {
			print("Skipping creation of .xcassets file as no path provided")
		}
	}

	// MARK: - Utilities

	private func retrieveImages() throws -> [FoundIconImage] {
		try FileManager.default.contentsOfDirectory(
			at: iconsDirectory,
			includingPropertiesForKeys: nil,
			options: []
		)
		.compactMap { FoundIconImage(fileURL: $0) }
	}

	private func primaryIconEntry(infoPlistPath: String) throws -> InfoPlistIconEntry {
		guard let data = FileManager.default.contents(atPath: infoPlistPath) else {
			throw BianError.invalidPath
		}
		let entries = try PropertyListDecoder().decode(InfoPlistBundleIcons.self, from: data)
		return entries.CFBundleIcons.CFBundlePrimaryIcon
	}

	private func createAssetsFile(path: String, images: [FoundIconImage]) throws {
		let mapped = FoundIconImagesParser.mapped(from: images)
		try XCAssetsGenerator.create(from: mapped, path: path, fileManager: .default)
	}
}

Bian.main()
